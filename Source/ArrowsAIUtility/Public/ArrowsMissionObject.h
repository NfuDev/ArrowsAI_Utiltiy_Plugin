// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "Tickable.h"
#include "MissionAction.h"
#include "ArrowsMissionObject.generated.h"

/**
 * 
 */

/*Structure To Hold Each Action And It's State, Done Or Not Done , For UI Porposes, Call [Get UI Text()] To Read This Struct Member , the structure was not okay to expose functions so the functions is moved 
to the class with the name get action info*/
 USTRUCT(BlueprintType)
 struct FMissionActionStates
 {
 	GENERATED_BODY()
 
 	UPROPERTY(BlueprintReadWrite, EditAnywhere)
 	TSubclassOf<UMissionAction> MissionAction;
 
 	UPROPERTY(BlueprintReadWrite, EditAnywhere)
 	int32 Count;
 
 	UPROPERTY(BlueprintReadWrite, EditAnywhere)
 	bool Done;

    UMissionAction* GetMissionDefaults()
    { 
        if (MissionAction)
        {
            UMissionAction* Value = MissionAction.GetDefaultObject();
            return Value;
        }

        return nullptr;
    }
 };

UENUM(BlueprintType)
enum class EMissionType : uint8
{
    Regulared UMETA(DisplayName = "Regular Mission"),
    Timed UMETA(DisplayName = "Mission With Timer")
};

UCLASS(Blueprintable, BlueprintType , meta = (ToolTip= "Simple UObject Handles Missions Basic Functionalities For You"))
class ARROWSAIUTILITY_API UArrowsMissionObject :  public UObject , public FTickableGameObject
{
    GENERATED_BODY()


public:
    /*Called When Mission Object Is Generated By The Mission Component*/
    UFUNCTION(BlueprintNativeEvent, meta = (AllowPrivateAcess = true))
    void MissionBegin();

    /*Mission Tick , To Further Emplement Mission Logics*/
    UFUNCTION(BlueprintNativeEvent, meta = (AllowPrivateAcess = true))
    void MissionTick(float DeltaTime);

    /*Called When Mission is Done And Returns A Bolean About it , Called When We add new action done or when mission timer is done*/
    UFUNCTION(BlueprintNativeEvent, meta = (AllowPrivateAcess = true))
    void MissionEnd(bool Success);

    /*Call This Function From Assossiated Mission Actors To Tell The Mission That The Certain Action Is Done, Passing Thier Reference To Make Sure The Mission
    Wont Get Confused If Some Actions Are Done And They Are Part Of The Requirements , But not Assossiated With it , Like Killing Enemies , the kill action is general you can kill some enemies 
    that are not part of the killing requirement for this mission*/
    UFUNCTION(BlueprintCallable, meta = (AllowPrivateAcess = true))
    void MissionActionPreformed(AActor* Source, TSubclassOf<UMissionAction> PreformedAction);

    /*Called To Assossiate Cartain Actors With This Mission*/
    UFUNCTION(BlueprintCallable, meta = (AllowPrivateAcess = true))
    void AddAssossiatedActor(AActor* Source);

    UPROPERTY()
    TArray<AActor*> AssossiatedActors;

    /*Get Specific Action Info For UI Display*/
    UFUNCTION(BlueprintCallable, BlueprintPure ,Category = "Mission Core", meta = (AllowPrivateAcess = true))
    void GetActionInfo(FMissionActionStates ActionState , FText& ActionText, int32& _Count, bool& _Done);

    UFUNCTION(BlueprintCallable, Category = "Mission Core", meta = (AllowPrivateAcess = true))
    void InitActionStates();

    /*this is a Function to check if all mission requirements are done*/
    UFUNCTION(BlueprintCallable, Category = "Mission Core", meta = (AllowPrivateAcess = true))
    bool CheckStatesForSucess();

    virtual void MissionBegin_Implementation();

    virtual void MissionTick_Implementation(float DeltaTime);

    virtual void MissionEnd_Implementation(bool Success);

    virtual void PostInitProperties() override;

    UWorld* GetWorld() const;
   
   
    /*Define The Mission Behaviour, regular mission with fail when black listed actions happens, timed missions fails when timer is out or black listed actions are done*/
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Mission Settings")
    EMissionType MissionType;

    /*Mission Timer In Seconds, in which the mission will fail after this time*/
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Mission Settings", meta = (EditCondition = "MissionType == EMissionType::Timed", EditConditionHides))
    float Time;

    /*The Class Of The Next Mission To Start When The Current Mission Is Finished Successfully*/
    UPROPERTY(EditAnywhere, Category = "Mission Settings")
    TSubclassOf<UArrowsMissionObject> NextMission;

    /*Array Of Actions That Are Required For The Current Mission To Succeed*/
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Mission Settings")
    TArray<TSubclassOf<UMissionAction>> MissionRequiredActions;

    /*Use For UI Only , To Showcase The Status Of Each Mission Task, Use [GetActionInfo()] To Get The Information For Certain Action*/
    UPROPERTY(BlueprintReadWrite, Category = "Mission Settings")
    TArray<FMissionActionStates> MissionActionsState;

    /*Actions Done By The Player During This Mission Is Being Active*/
    UPROPERTY()
    TArray<TSubclassOf<UMissionAction>> DoneActions;

    // Overriding Tickable object functions 

       virtual void Tick(float DeltaTime) override;

       virtual ETickableTickType GetTickableTickType() const override
       {
           return ETickableTickType::Always;
       }
       virtual TStatId GetStatId() const override
       {
           RETURN_QUICK_DECLARE_CYCLE_STAT(UArrowsMissionObject, STATGROUP_Tickables);
       }
       virtual bool IsTickableWhenPaused() const
       {
           return true;
       }
       virtual bool IsTickableInEditor() const
       {
           return false;
       }

private:
    // The last frame number we were ticked.
    // We don't want to tick multiple times per frame 
    uint32 LastFrameNumberWeTicked = INDEX_NONE;

};
