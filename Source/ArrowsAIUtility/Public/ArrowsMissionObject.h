// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "MissionAction.h"
#include "ArrowsMissionObject.generated.h"

/**
 * 
 */

/*Structure To Hold Each Action And It's State, Done Or Not Done , For UI Porposes, Call [Get UI Text()] To Read This Struct Member , the structure was not okay to expose functions so the functions is moved 
to the class with the name get action info*/
 USTRUCT(BlueprintType)
 struct FMissionActionStates
 {
 	GENERATED_BODY()
 
 	UPROPERTY(BlueprintReadWrite, EditAnywhere)
 	TSubclassOf<UMissionAction> MissionAction;
 
 	UPROPERTY(BlueprintReadWrite, EditAnywhere)
 	int32 Count;

    UPROPERTY(BlueprintReadWrite, EditAnywhere)
    int32 TotalCount;
 
 	UPROPERTY(BlueprintReadWrite, EditAnywhere)
 	bool Done;

    UMissionAction* GetMissionDefaults()
    { 
        if (MissionAction)
        {
            UMissionAction* Value = MissionAction.GetDefaultObject();
            return Value;
        }

        return nullptr;
    }
 };

UENUM(BlueprintType)
enum class EMissionType : uint8
{
    Regulared UMETA(DisplayName = "Regular Mission"),
    Timed UMETA(DisplayName = "Mission With Timer")
};

UENUM(BlueprintType)
enum class EMissionTimerType : uint8
{
    TotalSeconds  UMETA(DisplayName = "Total Seconds"),
    Formatted  UMETA(DisplayName = "Formatted Time")
};

UENUM(BlueprintType)
enum class EMissionState : uint8
{
    InProgress,
    Paused,
    Succeeded,
    Failed
};

UENUM(BlueprintType)
enum class EActionInfoGetType : uint8
{
    Total_Done_Decrementally UMETA(DisplayName = "Total / To Do"),
    Total_Done_Increamentally  UMETA(DisplayName = "Total / Done"),
    Done_Decrementally  UMETA(DisplayName = "Get To Do"),
    Done_Increamentally UMETA(DisplayName = "Get Done")
};


UCLASS(Blueprintable, BlueprintType , meta = (ToolTip= "Simple UObject Handles Missions Basic Functionalities For You"))
class ARROWSAIUTILITY_API UArrowsMissionObject :  public UObject
{

    GENERATED_BODY()


public:
    /*Called When Mission Object Is Generated By The Mission Component*/
    UFUNCTION(BlueprintNativeEvent, meta = (AllowPrivateAcess = true))
    void MissionBegin();

    /*Mission Tick , To Further Emplement Mission Logics*/
    UFUNCTION(BlueprintNativeEvent, meta = (AllowPrivateAcess = true))
    void MissionTick(float DeltaTime);

    /*Called When Mission is Done And Returns A Bolean About it , Called When We add new action done or when mission timer is done*/
    UFUNCTION(BlueprintNativeEvent, meta = (AllowPrivateAcess = true))
    void MissionEnd(bool Success);

    virtual void MissionBegin_Implementation();

    virtual void MissionTick_Implementation(float DeltaTime);

    virtual void MissionEnd_Implementation(bool Success);

    UWorld* GetWorld() const;

    /*Call This Function From Assossiated Mission Actors To Tell The Mission That The Certain Action Is Done, Passing Thier Reference To Make Sure The Mission
    Wont Get Confused If Some Actions Are Done And They Are Part Of The Requirements , But not Assossiated With it , Like Killing Enemies , the kill action is general you can kill some enemies 
    that are not part of the killing requirement for this mission*/
    UFUNCTION(BlueprintCallable, meta = (AllowPrivateAcess = true))
    void MissionActionPreformed(AActor* Source, TSubclassOf<UMissionAction> PreformedAction);

    /*Called To Assossiate Cartain Actors With This Mission*/
    UFUNCTION(BlueprintCallable, meta = (AllowPrivateAcess = true))
    void AddAssossiatedActor(AActor* Source);

    UPROPERTY()
    TArray<AActor*> AssossiatedActors;

    /*Get Specific Action Info For UI Display*/
    UFUNCTION(BlueprintCallable, BlueprintPure ,Category = "Mission Core", meta = (AllowPrivateAcess = true))
    void GetActionInfo(FMissionActionStates ActionState, EActionInfoGetType GetterType, FText& ActionText, int32& _Count, bool& _Done);

    UFUNCTION()
    void InitActionStates();

    /*this is a Function to check if all mission requirements are done*/
    UFUNCTION()
    bool CheckStatesForSucess();

    /*Updated logics to keep track of mission progress*/
    UFUNCTION()
    void UpdateMissionStates(TSubclassOf<UMissionAction> PreformedAction);

    /*Define The Mission Behaviour, regular mission with fail when black listed actions happens, timed missions fails when timer is out or black listed actions are done*/
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Mission Settings")
    EMissionType MissionType;

    UPROPERTY()
    EMissionState CurrentMissionState;

    /*Mission Timer In Seconds, in which the mission will fail after this time*/
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Mission Settings", meta = (EditCondition = "MissionType == EMissionType::Timed", EditConditionHides))
    float MissionTime;

    /*Deifnes the Timer Behaviour of it count down or count up (the count up best use in mission where you need to finish in less time for better score)*/
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Mission Settings", meta = (EditCondition = "MissionType == EMissionType::Timed", EditConditionHides))
    bool CountDown;

    UPROPERTY()
    FTimerHandle MissionTimer;


    UFUNCTION()
    void MissionTimeOver();

    /*Get The Time For UI Representation , you can get formatted time or get total seconds of needed*/
    UFUNCTION(BlueprintPure, BlueprintCallable , Category = "Mission Core")
    void GetMissionTime(EMissionTimerType TimerType, FText& Time, float& Counter);

    /*Called To Pause Mission best use when the mission is timed , and if it used with regular missions it will be okay and prevent [MissionEnd()] calls , but the mission will keep track of progress too
    and when it is resumed it will call the Mission End Event*/
    UFUNCTION(BlueprintCallable, Category = "Mission Core")
    void PauseMission(bool Pause);

    /*The Class Of The Next Mission To Start When The Current Mission Is Finished Successfully*/
    UPROPERTY(EditAnywhere, Category = "Mission Settings")
    TSubclassOf<UArrowsMissionObject> NextMission;

    /*Array Of Actions That Are Required For The Current Mission To Succeed , if there was multiple elements of same action the system will take the first one into consideration, to take 
    them all you need to tick the countable option in the mission action*/
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Mission Settings")
    TArray<TSubclassOf<UMissionAction>> MissionRequiredActions;

    /*List of actions that if happened the mission is going to fail , like maybe adding a npc death action and if this npc death happened then the mission will fail*/
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Mission Settings")
    TArray<TSubclassOf<UMissionAction>> MissionBlackListedActions;

    /*Use For UI Only , To Showcase The Status Of Each Mission Task, Use [GetActionInfo()] To Get The Information For Certain Action*/
    UPROPERTY(BlueprintReadWrite, Category = "Mission Settings")
    TArray<FMissionActionStates> MissionActionsState;

 


};
