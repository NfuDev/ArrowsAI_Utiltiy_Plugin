// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "MissionAction.h"
#include "MissionFadeWidget.h"
#include "ArrowsMissionObject.generated.h"

/**
 * 
 */

class UArrowsMissionComponent;


/*Structure To Hold Each Action And It's State, Done Or Not Done , For UI Porposes, Call [Get UI Text()] To Read This Struct Member , the structure was not okay to expose functions so the functions is moved 
to the class with the name get action info*/
 USTRUCT(BlueprintType)
 struct FMissionActionStates
 {
 	GENERATED_BODY()
 
 	UPROPERTY(BlueprintReadWrite, EditAnywhere)
 	TSubclassOf<UMissionAction> MissionAction;
 
 	UPROPERTY(BlueprintReadWrite, EditAnywhere)
 	int32 Count;

    UPROPERTY(BlueprintReadWrite, EditAnywhere)
    int32 TotalCount;
 
 	UPROPERTY(BlueprintReadWrite, EditAnywhere)
 	bool Done;

    UMissionAction* GetMissionDefaults()
    { 
        if (MissionAction)
        {
            UMissionAction* Value = MissionAction.GetDefaultObject();
            return Value;
        }

        return nullptr;
    }

    int32 GetMyIndex(TArray<FMissionActionStates> InArray)
    {
        int32 _Index = 0;
        for (int i = 0; i <= InArray.Num() - 1; i++)
        {
            FMissionActionStates Itirator = InArray[i];

            if (Itirator.MissionAction == MissionAction)
            {
                _Index = i;
                return _Index;
            }
        }

        return INDEX_NONE;
    }
 };

UENUM(BlueprintType)
enum class EMissionType : uint8
{
    Regulared UMETA(DisplayName = "Regular Mission"),
    Timed UMETA(DisplayName = "Mission With Timer")
};

UENUM(BlueprintType)
enum class EMissionTimerType : uint8
{
    TotalSeconds  UMETA(DisplayName = "Total Seconds"),
    Formatted  UMETA(DisplayName = "Formatted Time")
};

UENUM(BlueprintType)
enum class EMissionState : uint8
{
    InProgress,
    Paused,
    Succeeded,
    Failed
};

UENUM(BlueprintType)
enum class EMissionStatusType : uint8
{
    ShowAll UMETA(DisplayName = "All Action Shown"),
    OneByOne UMETA(DisplayName = "Currently + Next")
};

UENUM(BlueprintType)
enum class EMissionFaluireType : uint8
{
    Timer UMETA(DisplayName = "Time Out"),
    DoneAction UMETA(DisplayName = "black listed action")
};

UENUM(BlueprintType)
enum class EActionInfoGetType : uint8
{
    Total_Done_Decrementally UMETA(DisplayName = "Total / To Do"),
    Total_Done_Increamentally  UMETA(DisplayName = "Total / Done"),
    Done_Decrementally  UMETA(DisplayName = "Get To Do"),
    Done_Increamentally UMETA(DisplayName = "Get Done")
};


UCLASS(Blueprintable, BlueprintType , meta = (ToolTip= "Simple UObject Handles Missions Basic Functionalities For You"))
class ARROWSAIUTILITY_API UArrowsMissionObject :  public UObject
{

    GENERATED_BODY()

        UArrowsMissionObject();

public:
    /*Called When Mission Object Is Generated By The Mission Component*/
    UFUNCTION(BlueprintNativeEvent, meta = (AllowPrivateAcess = true))
    void MissionBegin(bool WasRestarted);

    /*Called When Mission Tasks Statues Updates*/
    UFUNCTION(BlueprintNativeEvent, meta = (AllowPrivateAcess = true))
    void OnMissionUpdates();

    /*Mission Tick , To Further Emplement Mission Logics*/
    UFUNCTION(BlueprintNativeEvent, meta = (AllowPrivateAcess = true))
    void MissionTick(float DeltaTime);

    /*Called When Mission is Done And Returns A Bolean About it , Called When We add new action done or when mission timer is done*/
    UFUNCTION(BlueprintNativeEvent, meta = (AllowPrivateAcess = true))
    void MissionEnd(bool Success);

    /*called after failing the mission when auto restart is ON!, implement you widget removal and also destroying all actors spwaned by this mission in this event so when the auto restart fires no old data
    remains , you must remove all data when the mission is auto restarted , do not delay any actions since the auto restart will fire after the fade direcly (you have 3 seconds to clean)*/
    UFUNCTION(BlueprintNativeEvent, meta = (AllowPrivateAcess = true))
    void OnMissionRestart();

    /*use this one when you are using a one by one action statues , so you can excute the logic for specific task only when it is added to the list
    * @param ActivatedAction the new task that is added to the task list in the ui
    * @param bIsCountable if it is a countable action or task, so you can decide what to do with the event according to this boolean
    * @param Count the total count of specific action , this is the sum of all actions from the same class if found multiple in one requirement array 
    */
    UFUNCTION(BlueprintNativeEvent, meta = (AllowPrivateAcess = true))
    void OnTaskActivated(TSubclassOf<UMissionAction> ActivatedAction, bool bIsCountable, int32 Count);

    //to see what next action to activate and call the event
    UFUNCTION()
    void OnActionDone(TSubclassOf<UMissionAction> DoneAction, int32 Index);

    virtual void MissionBegin_Implementation(bool WasRestarted);

    virtual void OnMissionUpdates_Implementation();

    virtual void MissionTick_Implementation(float DeltaTime);

    virtual void MissionEnd_Implementation(bool Success);

    virtual void OnMissionRestart_Implementation();

    virtual void OnTaskActivated_Implementation(TSubclassOf<UMissionAction> ActivatedAction, bool bIsCountable, int32 Count);

    UWorld* GetWorld() const;

    /*Call This Function From Assossiated Mission Actors To Tell The Mission That The Certain Action Is Done, Passing Thier Reference To Make Sure The Mission
    Wont Get Confused If Some Actions Are Done And They Are Part Of The Requirements , But not Assossiated With it , Like Killing Enemies , the kill action is general you can kill some enemies 
    that are not part of the killing requirement for this mission*/
    UFUNCTION(BlueprintCallable, Category = "Mission Core", meta = (AllowPrivateAcess = true))
    void MissionActionPreformed(AActor* Source, TSubclassOf<UMissionAction> PreformedAction);

    /*Called To Assossiate Cartain Actors With This Mission*/
    UFUNCTION(BlueprintCallable, Category = "Mission Core",  meta = (AllowPrivateAcess = true))
    void AddAssossiatedActor(AActor* Source);

    UPROPERTY()
    TArray<AActor*> AssossiatedActors;

    /*Get Specific Action Info For UI Display
    *@param FixTextFormat set true when using arabic fonts that shows brakets flipped
    */
    UFUNCTION(BlueprintCallable, BlueprintPure ,Category = "Mission Core", meta = (AllowPrivateAcess = true))
    void GetActionInfo(FMissionActionStates ActionState, EActionInfoGetType GetterType, bool FixTextFormat, FText& ActionText, int32& _Count, bool& _Done);

    UFUNCTION()
    void InitActionStates();

    /*this is a Function to check if all mission requirements are done*/
    UFUNCTION()
    bool CheckStatesForSucess();

    /*Updated logics to keep track of mission progress*/
    UFUNCTION()
    void UpdateMissionStates(TSubclassOf<UMissionAction> PreformedAction);

    /*The Name Of The Mission*/
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Mission Settings")
    FText MissionName;

    /*Mission Discribtion*/
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Mission Settings")
    FText MissionDiscribtion;

    /*Define The Mission Behaviour, regular mission with fail when black listed actions happens, timed missions fails when timer is out or black listed actions are done*/
    UPROPERTY(EditAnywhere, Category = "Mission Settings")
    EMissionType MissionType;

    UPROPERTY()
    EMissionState CurrentMissionState;

    UPROPERTY()
    EMissionFaluireType MissionFaluireType;

    /*returns the reason for the mission to fail, you can switch on the reason and if it was timer then you can print a message to tell the player so and 
    if it was action from the black list was done then you can tell that too, this is like "mission faild , NPC died", when the black listed (NPC_Die) happens , this is all just example
    @returns Reason type [Time Out or Bad thing happened]
    */
    UFUNCTION(BlueprintPure, BlueprintCallable, Category = "Mission Core")
    FORCEINLINE EMissionFaluireType GetMissionFaliureInfo(FText& CausedAction)
    {
        UMissionAction* ActionDefaults = FailureCauseAction.GetDefaultObject();

        CausedAction = IsValid(ActionDefaults) ? ActionDefaults->ActionText : FText::FromString("Black Listed Action Happened");
        return MissionFaluireType;
    };

    /*Mission Timer In Seconds, in which the mission will fail after this time*/
    UPROPERTY(EditAnywhere, Category = "Mission Settings", meta = (EditCondition = "MissionType == EMissionType::Timed", EditConditionHides))
    float MissionTime;


    /*Deifnes the Timer Behaviour of it count down or count up (the count up best use in mission where you need to finish in less time for better score)*/
    UPROPERTY(EditAnywhere, Category = "Mission Settings", meta = (EditCondition = "MissionType == EMissionType::Timed", EditConditionHides))
    bool CountDown;

    /*whether if the mission auto restart when faild or it should let the player go and start the mission like gta style, the auto restart functions after 3 seconds from the failed end
    and it also prevents the blueprint on restart event so they wont get mixed up, to implement your own logic leave this option disabled, it also makes the mission starts the next one automatically*/
    UPROPERTY(EditAnywhere, Category = "Mission Settings")
    bool AutoRestart;

    /*if the mission should go to next mission automatically or not*/
    UPROPERTY(EditAnywhere, Category = "Mission Settings")
    bool AutoGoNextMission;


    /* the delay for the restart or for going to next mission auto calls, this is the time the mission will take before fading in after the fade out */
    UPROPERTY(EditAnywhere, Category = "Mission Settings")
    float AutoCallsDelay;

    /*should the screen fade when restart or start the mission , this is must use if [mission in place ] boolean was false, meaning the mission will set a new 
    transform for the player, so we fade and hide the transition, if you want to use custom fade disable this option and implement you logic in mission end event and in mission restart event*/
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Mission Settings")
    bool MissionTransitionFade;//No Need For This 

    /*if the mission starts where the player is and do not set his location , if this is false then you specify a location for the mission to put the player in, dont forget to set the start transform
    or the player will be moved to the (0, 0, 0) and fall to the infinity*/
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Mission Settings")
    bool MissionInPlace;


    UPROPERTY(BlueprintReadOnly)
    bool bWasRestarted;

    /*Fade Animation Class*/
    UPROPERTY()
    TSubclassOf<UMissionFadeWidget> FadeWidgetClass;

    UPROPERTY()
    UMissionFadeWidget* FadeWidget;

    UFUNCTION()
    void ForceFadeAnimation();//for internal logic dont expose use the below function to force fade the screen, this is called via the mission component to force startup fade on missions that are started in place 

    /*Fades Out The Screen with the rate givin, best use when you want to start new mission that is not set to [start in place]*/
    UFUNCTION(BlueprintCallable, Category = "Mission Core")
    void MissionScreenFade(float Rate);

    /*To auto start new mission after a delay since this logic i found my self forced to implement in my blueprint logics for all missions so i decided to make it part of the mission core logics*/
    UFUNCTION()
    void DelayedStartNewMission();

    UFUNCTION()
    void DelayedMissionFade();

    /*the location where the player should be in the world when the mission is started or restarted */
    UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (EditCondition = "MissionInPlace == false", EditConditionHides), Category = "Mission Settings")
    FTransform StartLocation;

    /*Get The Time The User Set For The Mission*/
    UFUNCTION(BlueprintPure, BlueprintCallable, Category = "Mission Core")
    FORCEINLINE float GetMissionUserTime(){ return MissionTime; };

    /*Get The Mission Requirement List For Reading , use this when you have any event or thing depending on the count of action , if you want to spawn like 10K enemies from one action that has this count 
    you need a way to get this action and do the spawn , use this function to get all requirements and use the index of the action you know it needs to spawn stuff according to it and assossiate the spawn with the 
    mission*/
    UFUNCTION(BlueprintPure, BlueprintCallable, Category = "Mission Core")
    FORCEINLINE TArray<TSubclassOf<UMissionAction>> GetMissionRequirements() { return MissionRequiredActions; };

    /*Get Only Countable Requirements*/
    UFUNCTION(BlueprintPure, BlueprintCallable, Category = "Mission Core")
    FORCEINLINE TArray<TSubclassOf<UMissionAction>> GetCountableRequirementOnly()
    {
        TArray<TSubclassOf<UMissionAction>> TempArray;

        for (auto& RequiredAction : MissionRequiredActions)
        {
            UMissionAction* BaseClass = RequiredAction.GetDefaultObject();
            if (BaseClass->Countable)
            {
                TempArray.Add(RequiredAction);
            }
        }

        return TempArray;
    };
  

    UPROPERTY()
    FTimerHandle MissionTimer;

    UPROPERTY()
    FTimerHandle RestartCounter;

    /*To delay the restart by amount of time*/
    UFUNCTION()
    void TriggerRestartCounter();

    float totalRemaining;// moved the decleration here so the call for the function wont reset the value to zero so we can use this value later in the blueprint to check for score or what so ever

    UFUNCTION()
    void MissionTimeOver();

    /*Get The Time For UI Representation, you can get formatted time or get total seconds If needed*/
    UFUNCTION(BlueprintPure, BlueprintCallable , Category = "Mission Core")
    void GetMissionTime(EMissionTimerType TimerType, FText& Time, float& Counter);

    /*Called To Pause Mission best use when the mission is timed , and if it used with regular missions it will be okay and prevent [MissionEnd()] calls , but the mission will keep track of progress too
    and when it is resumed it will call the Mission End Event*/
    UFUNCTION(BlueprintCallable, Category = "Mission Core")
    void PauseMission(bool Pause);

    /*The Class Of The Next Mission To Start When The Current Mission Is Finished Successfully*/
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Mission Settings")
    TSubclassOf<UArrowsMissionObject> NextMission;

    /*Array Of Actions That Are Required For The Current Mission To Succeed , if there was multiple elements of same action the system will take the first one into consideration, to take 
    them all you need to tick the countable option in the mission action*/
    UPROPERTY(EditAnywhere, Category = "Mission Settings")
    TArray<TSubclassOf<UMissionAction>> MissionRequiredActions;

    /*List of actions that if happened the mission is going to fail , like maybe adding a npc death action and if this npc death happened then the mission will fail*/
    UPROPERTY(EditAnywhere, Category = "Mission Settings")
    TArray<TSubclassOf<UMissionAction>> MissionBlackListedActions;

    /*this holds the */
    UPROPERTY()
    TSubclassOf<UMissionAction> FailureCauseAction;

    /*Use For UI Only , To Showcase The Status Of Each Mission Task, Use [GetActionInfo()] To Get The Information For Certain Action*/
    UPROPERTY(BlueprintReadOnly, Category = "Mission Settings")
    TArray<FMissionActionStates> MissionActionsState;

 
    /*Reference to the mission component*/
    UPROPERTY(BlueprintReadOnly, Category = "Mission Settings")
    UArrowsMissionComponent* MissionComponent;

    /*here make a function to retrive the mission status according to new enum to represent status type
    (all shown, or shown one by one after each other when each one is done) and also hide the array so there wont be direct access*/

    UFUNCTION(BlueprintPure, BlueprintCallable, Category = "Mission Core")
    TArray<FMissionActionStates>GetMissionStatues(EMissionStatusType StatusType);

};
